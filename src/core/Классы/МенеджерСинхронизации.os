#Использовать logos
#Использовать tempfiles
#Использовать v8runner
#Использовать v8storage
#Использовать strings
#Использовать 1commands
#Использовать gitrunner
#Использовать fs
#Использовать "./internal"

Перем Лог; // Объект, для логирования
Перем ЭтоWindows; // Булево, призная операционной системы WINDOWS
Перем УдалятьВременныеФайлы; // Булево, признак удаления временных файлов
Перем КоличествоЦикловОжиданияЛицензииПоУмолчанию; // Число, количество попыток получения лицензии

Перем РабочийКаталогСохр; // Строка, рабочий каталог для класса <ГитРепозиторий>
Перем ГитРепозиторийСохр; // Объект.ГитРепозиторий
// Определяем мин количество коммитов между разницей версии уже в git и в хранилище
// для случаев, когда пересоздали хранилище и в гите находится версия 1234, а в хранилище 4,
// тогда вызываем исключение если разница в коммитах больше чем на эту велечину.
Перем МинимальнаяРазницаМеждуКоммитамиНовогоХранилища;
Перем ОбработчикПодписок; // Объект.МенеджерПодписок

Перем ХранилищеКонфигурации; // Объект.МенеджерХранилищаКонфигурации
Перем АвторизацияВХранилище; // Структура ключи <Пользователь>, <ПарольПользователя>

///////////////////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

Перем ДоменПочтыДляGitПоУмолчанию Экспорт; // Строка, домен пользователей по умолчанию
Перем ВерсияПлатформы Экспорт; // Строка, используемя версия 1С.Предприятие

#Область Публичное_API

// Устанавливает параметры авторизации в хранилище конфигурации 1С
//
// Параметры:
//   Пользователь - Строка - пользователь хранилища конфигурации 1С
//   Пароль - Строка - пароль пользователя хранилища конфигурации 1С
//
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция АвторизацияВХранилищеКонфигурации(Знач Пользователь, Знач Пароль) Экспорт

	Лог.Отладка("Установлена авторизация в хранилище пользователь <%1>, пароль <%2>", Пользователь, Пароль);
	АвторизацияВХранилище.Вставить("ПользовательХранилища" , Пользователь);
	АвторизацияВХранилище.Вставить("ПарольХранилища", Пароль);

	Возврат ЭтотОбъект;

КонецФункции

// Устанавливает признак необходимости удаления временных файлов
//
// Параметры:
//   ПарамУдалятьВременныеФайлы - Булево - признак необходимости удаления временных файлов
//
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция РежимУдаленияВременныхФайлов(Знач ПарамУдалятьВременныеФайлы) Экспорт

	УдалятьВременныеФайлы = ПарамУдалятьВременныеФайлы;
	Возврат ЭтотОбъект;

КонецФункции

// Устанавливает набор подписчиков
//
// Параметры:
//   НовыйИндексПодписчиков - Соответствие - набор подписчиков
//                                        * ключ - Строка - имя подписчика
//                                        * значение - Объект - ссылка на произвольный объект
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция ПодпискиНаСобытия(Знач НовыйИндексПодписчиков) Экспорт

	УстановитьОбработчикПодписок(НовыйИндексПодписчиков);
	Возврат ЭтотОбъект;

КонецФункции

// Устанавливает параметров для подписчиков
//
// Параметры:
//   НовыеПараметры - Соответствие - набор значений передаваемых подписчикам
//
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция ПараметрыПодписокНаСобытия(Знач НовыеПараметры) Экспорт

	ПараметрыПодписчиков = Новый ПараметрыПодписчиков(НовыеПараметры);

	ОбработчикПодписок.ПриПолученииПараметров(ПараметрыПодписчиков);
	Возврат ЭтотОбъект;

КонецФункции

// Устанавливает количество циклов ожидания лицензий
//
// Параметры:
//   КоличествоЦиклов - Число - количество циклов ожидания лицензии
//
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция ЦикловОжиданияЛицензии(Знач КоличествоЦиклов) Экспорт

	КоличествоЦикловОжиданияЛицензииПоУмолчанию = КоличествоЦиклов;
	Возврат ЭтотОбъект;

КонецФункции

// Устанавливает уровень вывода логов
//
// Параметры:
//   НовыйУровеньЛога - Строка - уровень вывода лога
//
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция УровеньЛога(Знач НовыйУровеньЛога) Экспорт

	Лог.УстановитьУровень(НовыйУровеньЛога);
	Возврат ЭтотОбъект;

КонецФункции

// Устанавливает версию платформы 1С
//
// Параметры:
//   НоваяВерсияПлатформы - Строка - версия платформы 1С используемой для работы
//
// Возвращаемое значение:
//   Объект.МенеджерСинхронизации - ссылка на текущий объект класса <МенеджерСинхронизации>
//
Функция ВерсияПлатформы(Знач НоваяВерсияПлатформы) Экспорт

	ВерсияПлатформы = НоваяВерсияПлатформы;
	Возврат ЭтотОбъект;

КонецФункции

// Основная функция синхронизации.
// Перемещает в git набор коммитов хранилища 1С
//
// Параметры:
//   КаталогРабочейКопии - Строка - путь к каталогу рабочей копии
//   ПутьКХранилищу - Строка - путь к хранилищу конфигурации
//
Процедура Синхронизировать(Знач КаталогРабочейКопии, Знач ПутьКХранилищу) Экспорт

	ОбработчикПодписок.ПередНачаломВыполнения(ПутьКХранилищу, КаталогРабочейКопии);

	Лог.Информация("Начата синхронизация с git");

	НастроитьХранилищеКонфигурации(ПутьКХранилищу, АвторизацияВХранилище);

	ТаблицаИсторииХранилища = ПрочитатьИзХранилищаИсториюКоммитовСАвторами(ПутьКХранилищу);

	ДополнитьТаблицуХранилищаИнформациейОСигнатуреПользователяВГит(ТаблицаИсторииХранилища, КаталогРабочейКопии);

	ТекущаяВерсия = НомерСинхронизированнойВерсии(КаталогРабочейКопии);

	Лог.Информация("Номер синхронизированной версии: " + ТекущаяВерсия);
	СледующаяВерсия = ТекущаяВерсия + 1;

	МаксимальнаяВерсияДляРазбора = ОпределитьМаксимальнуюВерсиюВХранилище(ТаблицаИсторииХранилища);
	Лог.Информация("Номер последней версии в хранилище: " + МаксимальнаяВерсияДляРазбора);

	Если СледующаяВерсия > МаксимальнаяВерсияДляРазбора
		И СледующаяВерсия - МаксимальнаяВерсияДляРазбора > МинимальнаяРазницаМеждуКоммитамиНовогоХранилища Тогда

		Лог.Ошибка("Несоответствие версий хранилища 1С и версию в репозитории Git.
		|Возможно, сократили/обрезали хранилище.
		|Для продолжения синхронизации измените файл VERSIONS в корне репозитория Git,
		|Исправьте версию %1 на правильную версию <= версии в хранилище %2", ТекущаяВерсия, МаксимальнаяВерсияДляРазбора);

		ВызватьИсключение СтрШаблон("Версия git %1 больше версии хранилища %2 на %3",
									ТекущаяВерсия,
									МаксимальнаяВерсияДляРазбора,
									СледующаяВерсия - МаксимальнаяВерсияДляРазбора);
	КонецЕсли;

	ОбработчикПодписок.ПередНачаломЦиклаОбработкиВерсий(ТаблицаИсторииХранилища,
														ТекущаяВерсия,
														СледующаяВерсия,
														МаксимальнаяВерсияДляРазбора);

	Пока СледующаяВерсия <= МаксимальнаяВерсияДляРазбора Цикл

		СтрокаВерсии = ТаблицаИсторииХранилища.Найти(СледующаяВерсия, "НомерВерсии");
		Если СтрокаВерсии <> Неопределено Тогда

			ОбработчикПодписок.ПередОбработкойВерсииХранилища(СтрокаВерсии, СледующаяВерсия);

			Попытка
				Лог.Информация("Получаем исходники для версии " + СледующаяВерсия + ", " + ТекущаяДата());

				ОбработчикПодписок.ПриОбработкеВерсииХранилища(СтрокаВерсии, СледующаяВерсия);
				ВыгрузитьВерсиюХранилищаКонфигурацииВИсходники(КаталогРабочейКопии, ПутьКХранилищу, СледующаяВерсия);

				Лог.Отладка("Фиксируем в файле VERSION версию " + СледующаяВерсия);
				ЗаписатьФайлВерсийГит(КаталогРабочейКопии, СледующаяВерсия);
				ВыполнитьКоммитГит(КаталогРабочейКопии,
									СтрокаВерсии.Комментарий,
									СтрокаВерсии.ПредставлениеАвтора,
									СтрокаВерсии.Дата);

			Исключение
				Лог.Отладка("Откатываем файл VERSION после ошибки");
				ЗаписатьФайлВерсийГит(КаталогРабочейКопии, ТекущаяВерсия);
				ВызватьИсключение;
			КонецПопытки;

			ТекущаяВерсия = СледующаяВерсия;
			ОбработчикПодписок.ПослеОбработкиВерсииХранилища(СтрокаВерсии, ТекущаяВерсия);

		КонецЕсли;

		СледующаяВерсия = СледующаяВерсия + 1;

	КонецЦикла;

	ЗавершитьПроцесс_TGitCache_exe();

	ОбработчикПодписок.ПослеОкончанияВыполнения(ПутьКХранилищу, КаталогРабочейКопии);

	УдалитьВременныеФайлыПриНеобходимости();

	Лог.Информация("Завершена синхронизации с git");

КонецПроцедуры

#КонецОбласти

#Область Функциональность_обработки_версии_хранилища_конфигурации

// Процедура выполняет выгрузку версии хранилища 1с в исходники
//
// Параметры:
//   КаталогРабочейКопии - Строка - Путь к каталогу рабочей копии git
//   ПутьКХранилищу - Строка - Путь к хранилищу 1С
//   НомерВерсии - Число - номер выгружаемой версии
//
Процедура ВыгрузитьВерсиюХранилищаКонфигурацииВИсходники(Знач КаталогРабочейКопии,
														Знач ПутьКХранилищу,
														Знач НомерВерсии) Экспорт

	Конфигуратор = ПолучитьМенеджерКонфигуратора();

	ОбработчикПодписок.ПередНачаломВыгрузкиВерсииХранилищаКонфигурации(Конфигуратор,
																		КаталогРабочейКопии,
																		ПутьКХранилищу,
																		НомерВерсии);

	ОбработчикПодписок.ПередЗагрузкойВерсииХранилищаКонфигурации(Конфигуратор,
																КаталогРабочейКопии,
																ПутьКХранилищу,
																НомерВерсии);

	ЗагрузитьВерсиюХранилищаВКонфигурацию(Конфигуратор, КаталогРабочейКопии, ПутьКХранилищу, НомерВерсии);

	КаталогВыгрузки = ВременныеФайлы.СоздатьКаталог();

	Лог.Отладка("Каталог выгрузки <%1> для версии <%2>", КаталогВыгрузки , НомерВерсии);

	ОбработчикПодписок.ПередВыгрузкойКонфигурациюВИсходники(Конфигуратор,
															КаталогРабочейКопии,
															КаталогВыгрузки,
															ПутьКХранилищу,
															НомерВерсии);

	ВыгрузитьКонфигурациюВИсходники(Конфигуратор, КаталогВыгрузки);

	ОбработчикПодписок.ПередОчисткойКаталогаРабочейКопии(Конфигуратор,
														КаталогРабочейКопии,
														КаталогВыгрузки,
														ПутьКХранилищу,
														НомерВерсии);

	ОчиститьКаталогРабочейКопии(КаталогРабочейКопии);

	ОбработчикПодписок.ПередПеремещениемВКаталогРабочейКопии(Конфигуратор,
															КаталогРабочейКопии,
															КаталогВыгрузки,
															ПутьКХранилищу,
															НомерВерсии);

	ПереместитьВКаталогРабочейКопии(КаталогРабочейКопии, КаталогВыгрузки);

	ОбработчикПодписок.ПослеОкончанияВыгрузкиВерсииХранилищаКонфигурации(Конфигуратор,
																		КаталогРабочейКопии,
																		ПутьКХранилищу,
																		НомерВерсии);

	УдалитьВременныеФайлыПриНеобходимости(Конфигуратор.КаталогСборки());
	УдалитьВременныеФайлыПриНеобходимости(КаталогВыгрузки);

КонецПроцедуры

#КонецОбласти

#Область Функциональность_загрузки_версии_из_хранилища

// Выполняет загрузку версии конфигурации из хранилища конфигурации
//
// Параметры:
//   Конфигуратор - Объект.УправлениеКонфигуратором - инициализированный класс <УправлениеКонфигуратором>
//   КаталогРабочейКопии - Строка - полный путь к рабочему каталогу копии
//   ПутьКХранилищу - Строка - полный путь к хранилищу конфигурации
//   НомерВерсии - Число - номер выгружаемой версии
//
Процедура ЗагрузитьВерсиюХранилищаВКонфигурацию(Знач Конфигуратор,
												Знач КаталогРабочейКопии,
												Знач ПутьКХранилищу,
												Знач НомерВерсии) Экспорт
	СтандартнаяОбработка = Истина;

	ОбработчикПодписок.ПриЗагрузкеВерсииХранилищаВКонфигурацию(Конфигуратор,
																КаталогРабочейКопии,
																ПутьКХранилищу,
																НомерВерсии,
																СтандартнаяОбработка);

	Если СтандартнаяОбработка Тогда

		ЗагрузитьВерсиюХранилищаВКонфигурациюСтандартнаяОбработка(Конфигуратор,
																НомерВерсии);

	КонецЕсли;

	ОбработчикПодписок.ПослеЗагрузкиВерсииХранилищаВКонфигурацию(Конфигуратор,
																КаталогРабочейКопии,
																ПутьКХранилищу,
																НомерВерсии);

КонецПроцедуры

// Стандартная обработка загрузки версии конфигурации из хранилища конфигурации
//
// Параметры:
//   Конфигуратор - Объект.УправлениеКонфигуратором - инициализированный класс <УправлениеКонфигуратором>
//   НомерВерсии - Число - номер выгружаемой версии
//
Процедура ЗагрузитьВерсиюХранилищаВКонфигурациюСтандартнаяОбработка(Конфигуратор,
																	Знач НомерВерсии)

	ХранилищеКонфигурации.УстановитьУправлениеКонфигуратором(Конфигуратор);

	КоличествоЦикловОжиданияЛицензии = ПолучитьКоличествоЦикловОжиданияЛицензииПоУмолчанию();

	Пока КоличествоЦикловОжиданияЛицензии >= 0 Цикл
		Попытка

			ХранилищеКонфигурации.ОбновитьКонфигурациюНаВерсию(НомерВерсии);
			Прервать;

		Исключение
			// проверим текст ошибки, если текст содержит информацию о необходимости конвертировать
			// тогда выполним конвертацию и повторно попытаемся загрузить файл
			ТекстОшибки = ВРег(ХранилищеКонфигурации.ПолучитьВыводКоманды());
			Если Найти(ТекстОшибки, Врег("Не обнаружено свободной лицензии!")) Тогда

				ПериодОжидания = 10000;
				Лог.Ошибка(ТекстОшибки);
				Лог.Информация("Повторное подключение через 10сек. Осталось попыток: <%1>", КоличествоЦикловОжиданияЛицензии);
				Приостановить(ПериодОжидания);

			Иначе

				ВызватьИсключение ТекстОшибки;

			КонецЕсли;

		КонецПопытки;

		Если ПолучитьКоличествоЦикловОжиданияЛицензииПоУмолчанию() <> 0 Тогда
			КоличествоЦикловОжиданияЛицензии = КоличествоЦикловОжиданияЛицензии - 1;
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

#КонецОбласти

#Область Функциональность_выгрузки_конфигурации_в_исходники

// Выполняет выгрузку версии конфигурации в исходники (стандартная обработка внутри)
//
// Параметры:
//   Конфигуратор - Объект.УправлениеКонфигуратором - инициализированный класс <УправлениеКонфигуратором>
//   КаталогВыгрузки - Строка - полный путь к временноиу каталогу выгрузки
//
Процедура ВыгрузитьКонфигурациюВИсходники(Знач Конфигуратор, Знач КаталогВыгрузки) Экспорт

	СтандартнаяОбработка = Истина;

	ОбработчикПодписок.ПриВыгрузкеКонфигурациюВИсходники(Конфигуратор, КаталогВыгрузки, СтандартнаяОбработка);

	Если СтандартнаяОбработка Тогда

		Конфигуратор.ВыгрузитьКонфигурациюВФайлы(КаталогВыгрузки);

	КонецЕсли;

	ОбработчикПодписок.ПослеВыгрузкиКонфигурациюВИсходники(Конфигуратор, КаталогВыгрузки);

КонецПроцедуры

#КонецОбласти

#Область Функциональность_очистки_каталога_рабочей_копии

// Выполняет очистку каталога рабочей копии
//
// Параметры:
//   КаталогРабочейКопии - Строка - полный путь к рабочему каталогу копии
//
Процедура ОчиститьКаталогРабочейКопии(Знач КаталогРабочейКопии) Экспорт

	СтандартнаяОбработка = Истина;

	СоответствиеИменФайловДляПропуска = Новый Соответствие;
	СоответствиеИменФайловДляПропуска.Вставить(".git", Истина);
	СоответствиеИменФайловДляПропуска.Вставить(ИмяФайлаАвторов(), Истина); // Соответствие авторов и транслитерации.
	СоответствиеИменФайловДляПропуска.Вставить(ИмяФайлаВерсииХранилища(), Истина); // Номер версии, может использоватся для синхронизации с хранилищем.

	ОбработчикПодписок.ПриОчисткеКаталогаРабочейКопии(КаталогРабочейКопии,
													 СоответствиеИменФайловДляПропуска,
													 СтандартнаяОбработка);

	Если СтандартнаяОбработка Тогда

		ОчиститьКаталогРабочейКопииСтандартнаяОбработка(КаталогРабочейКопии, СоответствиеИменФайловДляПропуска);

	КонецЕсли;

	ОбработчикПодписок.ПослеОчисткиКаталогаРабочейКопии(КаталогРабочейКопии, СоответствиеИменФайловДляПропуска);

КонецПроцедуры

// Стандартная обработка очистки каталога рабочей копии
//
// Параметры:
//   КаталогРабочейКопии - Строка - полный путь к рабочему каталогу копии
//   СоответствиеИменФайловДляПропуска - Соответствие - ключи имен файлов для пропуска при очистки каталога
//
Процедура ОчиститьКаталогРабочейКопииСтандартнаяОбработка(Знач КаталогРабочейКопии, СоответствиеИменФайловДляПропуска)

	ЕстьОшибкаУдаления = Ложь;
	КоличествоПопыток = 2;
	Для НомерПопытки = 1 По КоличествоПопыток Цикл
		МассивФайлов = НайтиФайлы(КаталогРабочейКопии, ПолучитьМаскуВсеФайлы());
		Если МассивФайлов.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;

		Для Каждого ЭлементМассива Из МассивФайлов Цикл
			Если СоответствиеИменФайловДляПропуска[ЭлементМассива.Имя] = Истина Тогда
				Продолжить;
			КонецЕсли;

			Попытка
				УдалитьФайлы(ЭлементМассива.ПолноеИмя);
			Исключение
				ЕстьОшибкаУдаления = Истина;
				Если НомерПопытки = КоличествоПопыток Тогда
					ВызватьИсключение;
				КонецЕсли;
			КонецПопытки;
		КонецЦикла;

		Если Не ЕстьОшибкаУдаления Тогда
			Прервать;
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

#КонецОбласти

#Область Функциональность_перемещения_файлов_в_каталог_рабочей_копии

// Выполняет перемещение файлов в каталог рабочей копии
//
// Параметры:
//   КаталогРабочейКопии - Строка - полный путь к рабочему каталогу копии
//   КаталогВыгрузки - Строка - полный путь к каталогу выгрузки
//
Процедура ПереместитьВКаталогРабочейКопии(Знач КаталогРабочейКопии, Знач КаталогВыгрузки) Экспорт

	СтандартнаяОбработка = Истина;

	ОбработчикПодписок.ПриПеремещенииВКаталогРабочейКопии(КаталогРабочейКопии,
														КаталогВыгрузки,
														СтандартнаяОбработка);

	Если СтандартнаяОбработка Тогда

		ПереместитьВКаталогРабочейКопииСтандартнаяОбработка(КаталогРабочейКопии,
															КаталогВыгрузки);

	КонецЕсли;

	ОбработчикПодписок.ПослеПеремещенияВКаталогРабочейКопии(КаталогРабочейКопии,
															КаталогВыгрузки);

КонецПроцедуры

// Стандартная обработка перемещения файлов в каталог рабочей копии
//
// Параметры:
//   КаталогРабочейКопии - Строка - полный путь к рабочему каталогу копии
//   КаталогВыгрузки - Строка - полный путь к каталогу выгрузки
//
Процедура ПереместитьВКаталогРабочейКопииСтандартнаяОбработка(Знач КаталогРабочейКопии,
															Знач КаталогВыгрузки)

	СписокФайлов = НайтиФайлы(КаталогВыгрузки, ПолучитьМаскуВсеФайлы(), Истина);
	Лог.Отладка("Найдено файлов выгрузки: %1 шт.", СписокФайлов.Количество());
	Лог.Отладка("КаталогРабочейКопии: %1 ", КаталогРабочейКопии);
	Для Каждого Файл Из СписокФайлов Цикл

		КорневойКаталог = КаталогВыгрузки;
		Если НЕ СтрЗаканчиваетсяНа(КорневойКаталог, ПолучитьРазделительПути()) Тогда
			КорневойКаталог = КорневойКаталог + ПолучитьРазделительПути();
		КонецЕсли;

		ИмяНовогоФайла = СтрЗаменить(Файл.ПолноеИмя, КорневойКаталог, "");

		Если Файл.ЭтоКаталог() Тогда

			ИмяКаталога = ОбъединитьПути(КаталогРабочейКопии, ИмяНовогоФайла);
			Лог.Отладка("Обрабатываю ИмяКаталога: %1 ", ИмяКаталога);
			ФайлКаталога = Новый Файл(ИмяКаталога);
			Если НЕ ФайлКаталога.Существует() Тогда
				СоздатьКаталог(ФайлКаталога.ПолноеИмя);
			КонецЕсли;

			Продолжить;

		КонецЕсли;

		НовыйФайл = Новый Файл(ОбъединитьПути(КаталогРабочейКопии, ИмяНовогоФайла));
		НовыйКаталог = Новый Файл(НовыйФайл.Путь);
		Если НЕ НовыйКаталог.Существует() Тогда
			СоздатьКаталог(НовыйКаталог.ПолноеИмя);
		КонецЕсли;

		КопироватьФайл(Файл.ПолноеИмя, НовыйФайл.ПолноеИмя);

	КонецЦикла;

КонецПроцедуры

#КонецОбласти

#Область Функциональность_работы_с_конфигуратором

// Подготавливает управление конфигуратором для выполнения операций
//
// Возвращаемое значение:
//   Объект.УправлениеКонфигуратором - инициализированный класс <УправлениеКонфигуратором>
//
Функция ПолучитьМенеджерКонфигуратора() Экспорт
	Конфигуратор = Новый УправлениеКонфигуратором;
	Логирование.ПолучитьЛог("oscript.lib.v8runner").УстановитьУровень(Лог.Уровень());
	КаталогСборки = ВременныеФайлы.СоздатьКаталог();
	Конфигуратор.КаталогСборки(КаталогСборки);
	Конфигуратор.ИспользоватьВерсиюПлатформы(ВерсияПлатформы);

	Возврат Конфигуратор;
КонецФункции

#КонецОбласти

#Область Функциональность_работы_с_ГитРепозиторием

// Подготавливает объект ГитРепозиторий для работы с git
//
// Параметры:
//   КаталогРабочейКопии - Строка - путь к каталогу рабочей копии git
//
// Возвращаемое значение:
//   Объект.ГитРепозиторий - подготовленный объект класса <ГитРепозиторий>
//
Функция ПолучитьГитРепозиторий(Знач КаталогРабочейКопии) Экспорт

	ФайлКаталога = Новый Файл(КаталогРабочейКопии);
	Если ФайлКаталога.ПолноеИмя = РабочийКаталогСохр Тогда
		ГитРепозиторий = ГитРепозиторийСохр;
	Иначе
		ГитРепозиторий = Новый ГитРепозиторий;
		ГитРепозиторий.УстановитьРабочийКаталог(КаталогРабочейКопии);
		ГитРепозиторий.УстановитьТихийРежимРаботы();

		ГитРепозиторий.УстановитьНастройку("core.quotepath", "false", РежимУстановкиНастроекGit.Локально);
		ГитРепозиторий.УстановитьНастройку("merge.ours.driver", "true", РежимУстановкиНастроекGit.Локально);

		ГитРепозиторий.УстановитьНормальныйРежимРаботы();

		РабочийКаталогСохр = ФайлКаталога.ПолноеИмя;
		ГитРепозиторийСохр = ГитРепозиторий;

	КонецЕсли;

	Возврат ГитРепозиторий;

КонецФункции // ПолучитьГитРепозиторий()

// Выполняет фиксацию изменений в локальном каталоге git
//
// Параметры:
//   КаталогРабочейКопии - Строка - полный путь к рабочему каталогу копии
//   Комментарий - Строка - комментарий изменений при фиксации
//   Автор - Строка - автор изменений при фиксации
//   Дата - Дата - дата изменений фиксации
//
Процедура ВыполнитьКоммитГит(Знач КаталогРабочейКопии, Знач Комментарий, Знач Автор, Знач Дата = Неопределено) Экспорт

	ОбработчикПодписок.ПередКоммитом(КаталогРабочейКопии, Комментарий, Автор, Дата);

	Если Дата = Неопределено Тогда
		Дата = ТекущаяДата();
	КонецЕсли;

	АвторДляГит = Автор;

	Лог.Отладка("Автор коммита: %1", АвторДляГит);
	ДатаДляГит = ДатаPOSIX(Дата);
	Лог.Отладка("Дата коммита: %1", ДатаДляГит);
	ИмяФайлаКомментария = ПодготовитьФайлКоммита(Комментарий);

	ГитРепозиторий = ПолучитьГитРепозиторий(КаталогРабочейКопии);
	ПроиндексироватьОтслеживаемыеФайлы = Истина;
	// Выполнение индексации всех измененных файлов
	ОбработчикПодписок.ПриКоммите(ГитРепозиторий,
				Комментарий,
				ПроиндексироватьОтслеживаемыеФайлы,
				ИмяФайлаКомментария,
				АвторДляГит,
				ДатаДляГит,
				АвторДляГит,
				ДатаДляГит);

	ГитРепозиторий.ВыполнитьКоманду(СтрРазделить("add -A .", " "));
	ГитРепозиторий.Закоммитить(Комментарий,
								ПроиндексироватьОтслеживаемыеФайлы,
								ИмяФайлаКомментария,
								АвторДляГит,
								ДатаДляГит,
								АвторДляГит,
								ДатаДляГит);
	Лог.Отладка("Вывод команды Commit: %1", СокрЛП(ГитРепозиторий.ПолучитьВыводКоманды()));

	ОбработчикПодписок.ПослеКоммита(ГитРепозиторий, КаталогРабочейКопии);

	ЗавершитьПроцесс_TGitCache_exe();

КонецПроцедуры

#КонецОбласти

#Область Функциональность_работы_с_таблицами_хранилища

// Выполняет чтение таблицы VERSIONS из хранилища 1С
//
// Параметры:
//   ПутьКХранилищу - Строка - путь к хранилищу 1С
//
// Возвращаемое значение:
//   ТаблицаВерсий - ТаблицаЗначений - инициализированная таблица с колонками:
//     * Дата                - Дата   - дата версии
//     * НомерВерсии         - Число  - номер версии
// 	   * Комментарий         - Строка - комментарий автора к версии
//     * Автор               - Строка - имя автора версии в хранилище
// 	   * Тэг                 - Строка - метка версии в хранилище
// 	   * ГУИД_Автора         - Строка - уникальный идентификатор автора версии
//     * ПредставлениеАвтора - Строка - представление автора для коммита в git
//
Функция ПрочитатьТаблицуИсторииХранилища(Знач ПутьКХранилищу) Экспорт

	СтандартнаяОбработка = Истина;

	ТаблицаВерсий = НоваяТаблицаИсторииВерсий();

	ОбработчикПодписок.ПриПолученииТаблицыВерсий(ТаблицаВерсий, ПутьКХранилищу, СтандартнаяОбработка);

	Если СтандартнаяОбработка Тогда

		Лог.Отладка("Получение таблицы версий средствами 1С.Предприятие");
		Если ХранилищеКонфигурации = Неопределено Тогда
			НастроитьХранилищеКонфигурации(ПутьКХранилищу, АвторизацияВХранилище);
		КонецЕсли;

		ТаблицаВерсийХранилища = ХранилищеКонфигурации.ПолучитьТаблицуВерсий();

		Для Каждого СтрокаВерсииХранилища Из ТаблицаВерсийХранилища Цикл

			СтрокаВерсии = ТаблицаВерсий.Добавить();
			СтрокаВерсии.НомерВерсии	= СтроковыеФункции.СтрокаВЧисло(СтрЗаменить(СтрокаВерсииХранилища.Номер, " ", ""));
			СтрокаВерсии.Автор 			= СтрокаВерсииХранилища.Автор;
			СтрокаВерсии.ГУИД_Автора 	= СтрокаВерсииХранилища.Автор;
			СтрокаВерсии.Дата 			= СтрокаВерсииХранилища.Дата;
			СтрокаВерсии.Комментарий 	= СтрокаВерсииХранилища.Комментарий;
			СтрокаВерсии.Тэг 			= ""; // теги в отчете не предоставляются

			СтрокаШаблонаЛога = "Добавили строку в таблицу версий:
			| Номер версии: %1
			| Автор:        %2
			| ГУИД_Автора:  %3
			| Дата:         %4
			| Комментарий:  %5
			|";
			Лог.Отладка(СтрокаШаблонаЛога, СтрокаВерсии.НомерВерсии,
										СтрокаВерсии.Автор,
										СтрокаВерсии.ГУИД_Автора,
										СтрокаВерсии.Дата,
										СтрокаВерсии.Комментарий);

		КонецЦикла;

	КонецЕсли;

	ТаблицаВерсий.Сортировать("НомерВерсии");

	ОбработчикПодписок.ПослеПолученияТаблицыВерсий(ТаблицаВерсий, ПутьКХранилищу);

	Возврат ТаблицаВерсий;

КонецФункции

// Считывает таблицу USERS пользователей хранилища
//
// Параметры:
//   ПутьКХранилищу - Строка - путь к хранилищу 1С
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица пользователей с колонками
//     * Автор               - Строка - имя автора версии в хранилище
//     * ПредставлениеАвтора - Строка - представление автора для коммита в git
// 	   * ГУИД_Автора         - Строка - уникальный идентификатор автора версии
//
Функция ПрочитатьТаблицуПользователейХранилища(Знач ПутьКХранилищу) Экспорт

	СтандартнаяОбработка = Истина;

	ТаблицаПользователей = НоваяТаблицаПользователейХранилища();

	ОбработчикПодписок.ПриПолученииТаблицыПользователей(ТаблицаПользователей, ПутьКХранилищу, СтандартнаяОбработка);

	Если СтандартнаяОбработка Тогда

		Если ХранилищеКонфигурации = Неопределено Тогда
			НастроитьХранилищеКонфигурации(ПутьКХранилищу, АвторизацияВХранилище);
		КонецЕсли;

		МассивАвторовХранилища = ХранилищеКонфигурации.ПолучитьАвторов();

		Для Каждого Автор Из МассивАвторовХранилища Цикл

			СтрокаВерсии = ТаблицаПользователей.Добавить();
			СтрокаВерсии.Автор 			= Автор;
			СтрокаВерсии.ГУИД_Автора 	= Автор;

		КонецЦикла;

	КонецЕсли;

	ОбработчикПодписок.ПослеПолученияТаблицыПользователей(ТаблицаПользователей, ПутьКХранилищу);

	Возврат ТаблицаПользователей;

КонецФункции

// Считывает из хранилища историю коммитов с привязкой к пользователям
//
// Параметры:
//   ПутьКХранилищу - Строка - путь к хранилищу 1С
//
// Возвращаемое значение:
//   ТаблицаВерсий - ТаблицаЗначений - инициализированная таблица с колонками:
//     * Дата                - Дата   - дата версии
//     * НомерВерсии         - Число  - номер версии
// 	   * Комментарий         - Строка - комментарий автора к версии
//     * Автор               - Строка - имя автора версии в хранилище
// 	   * Тэг                 - Строка - метка версии в хранилище
// 	   * ГУИД_Автора         - Строка - уникальный идентификатор автора версии
//     * ПредставлениеАвтора - Строка - представление автора для коммита в git
//
Функция ПрочитатьИзХранилищаИсториюКоммитовСАвторами(Знач ПутьКХранилищу) Экспорт

	ТаблицаВерсий = ПрочитатьТаблицуИсторииХранилища(ПутьКХранилищу);
	ТаблицаПользователей = ПрочитатьТаблицуПользователейХранилища(ПутьКХранилищу);

	ДополнитьТаблицуВерсийИменамиАвторов(ТаблицаВерсий, ТаблицаПользователей);
	ТаблицаВерсий.Сортировать("НомерВерсии");

	Возврат ТаблицаВерсий;

КонецФункции

// Прописывает в таблицы пользователей и версий информацию о git auth вида user <user@email.com>
//
// Параметры:
//   ТаблицаХранилища - ТаблицаЗначений - таблица истории хранилища конфигурации
//   КаталогРабочейКопии - Строка - путь к каталогу рабочей копии git
//
Процедура ДополнитьТаблицуХранилищаИнформациейОСигнатуреПользователяВГит(Знач ТаблицаХранилища, 
																		Знач КаталогРабочейКопии) Экспорт

	ПутьКФайлуСопоставления = ОбъединитьПути(КаталогРабочейКопии, ИмяФайлаАвторов());
	ТаблицаСопоставления = ПрочитатьФайлАвторовГитВТаблицуПользователей(ПутьКФайлуСопоставления);
	Для Каждого СтрокаТаблицы Из ТаблицаХранилища Цикл

		СтрокаПользователя = ТаблицаСопоставления.Найти(СтрокаТаблицы.Автор, "Автор");
		Если СтрокаПользователя = Неопределено Тогда
			ПредставлениеАвтора = СтрШаблон("%1 <%1@%2>", СтрокаТаблицы.Автор, Строка(ДоменПочтыДляGit()));
		Иначе
			ПредставлениеАвтора = строкаПользователя.ПредставлениеАвтора;
		КонецЕсли;

		СтрокаТаблицы.ПредставлениеАвтора = ПредставлениеАвтора;

	КонецЦикла;

КонецПроцедуры

#КонецОбласти

#Область Прочая_экпортная_функцинальность

// Возвращает количество циклов ожидания лицензий
//
// Возвращаемое значение:
//   Число - количество циклов ожидания лицензии
//
Функция ПолучитьКоличествоЦикловОжиданияЛицензииПоУмолчанию() Экспорт
	Возврат КоличествоЦикловОжиданияЛицензииПоУмолчанию;
КонецФункции

// Генерирует файл соответствия пользователей хранилища 1С и git
//
// Параметры:
//   ПутьКХранилищу - Строка - путь к хранилищу 1С
//   ВыходнойФайл - Строка - путь к файлу авторов
//
Процедура СформироватьПервичныйФайлПользователейДляGit(Знач ПутьКХранилищу, Знач ВыходнойФайл) Экспорт

	Лог.Отладка("Формируем первичный файл авторов:
	| Путь к хранилищу: <%1>
	| Выходной файл: <%2>", ПутьКХранилищу, ВыходнойФайл);

	ТаблицаПользователейХранилища = ПрочитатьТаблицуПользователейХранилища(ПутьКХранилищу);

	ЗаписатьТаблицуПользователейВФайлАвторовGit(ТаблицаПользователейХранилища, ВыходнойФайл, ДоменПочтыДляGit());

КонецПроцедуры

// Читает файл авторов и возвращает таблицу пользователей
//
// Параметры:
//   ПутьКФайлуАвторов - Строка - путь к файлу авторов
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица пользователей с колонками
//     * Автор               - Строка - имя автора версии в хранилище
//     * ПредставлениеАвтора - Строка - представление автора для коммита в git
// 	   * ГУИД_Автора         - Строка - уникальный идентификатор автора версии
//
Функция ПрочитатьФайлАвторовГитВТаблицуПользователей(Знач ПутьКФайлуАвторов) Экспорт

	Если НЕ ЗначениеЗаполнено(ПутьКФайлуАвторов) Тогда
		Возврат Неопределено;
	КонецЕсли;

	Файл = Новый Файл(ПутьКФайлуАвторов);
	Если Не Файл.Существует() Тогда
		Возврат НоваяТаблицаПользователейХранилища();
	КонецЕсли;

	Пользователи = НоваяТаблицаПользователейХранилища();

	Попытка
		ТекстовыйФайл = Новый ЧтениеТекста(ПутьКФайлуАвторов, "utf-8");
		СтрокаФайла = "";
		Пока СтрокаФайла <> Неопределено Цикл
			СтрокаФайла = ТекстовыйФайл.ПрочитатьСтроку();
			Индекс = Найти(СтрокаФайла, "=");
			Если Индекс > 0 Тогда

				Ключ = Лев(СтрокаФайла, Индекс - 1);
				АвторПредставление = Сред(СтрокаФайла, Индекс + 1);

				НоваяСтрока = Пользователи.Добавить();
				НоваяСтрока.ПредставлениеАвтора = АвторПредставление;
				НоваяСтрока.Автор = Ключ;
			КонецЕсли;
		КонецЦикла;

	Исключение
		Если ТекстовыйФайл <> Неопределено Тогда
			ОсвободитьОбъект(ТекстовыйФайл);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;

	Если ТекстовыйФайл <> Неопределено Тогда
		ОсвободитьОбъект(ТекстовыйФайл);
	КонецЕсли;

	Возврат Пользователи;

КонецФункции

// Наполняет каталог рабочей копии служебными данными
//
// Параметры:
//   КаталогРабочейКопии - Строка - путь к каталогу рабочей копии git
//   ПутьКХранилищу - Строка - путь к хранилищу 1С
//
Процедура НаполнитьКаталогРабочейКопииСлужебнымиДанными(Знач КаталогРабочейКопии, Знач ПутьКХранилищу) Экспорт

	КаталогИсходников = Новый Файл(КаталогРабочейКопии);
	Если Не КаталогИсходников.Существует() Тогда

		СоздатьКаталог(КаталогИсходников.ПолноеИмя);

	ИначеЕсли Не КаталогИсходников.ЭтоКаталог() Тогда

		ВызватьИсключение "Невозможно создать каталог " + КаталогИсходников.ПолноеИмя;

	КонецЕсли;

	СгенерироватьФайлAUTHORS(ПутьКХранилищу, КаталогИсходников.ПолноеИмя);
	СгенерироватьФайлVERSION(КаталогИсходников.ПолноеИмя);

КонецПроцедуры

// Производит проверку необходимости синхронизации с хранилищем
//
// Параметры:
//   КаталогРабочейКопии - Строка - Путь к каталогу рабочей копии git
//   ПутьКХранилищу - Строка - Путь к хранилищу 1С
//
// Возвращаемое значение:
//   Булево - признак необходимости синхронизации
//
Функция ТребуетсяСинхронизироватьХранилищеСГит(Знач КаталогРабочейКопии, Знач ПутьКХранилищу) Экспорт

	ТаблицаВерсий = ПрочитатьТаблицуИсторииХранилища(ПутьКХранилищу);
	ТекущаяВерсия = НомерСинхронизированнойВерсии(КаталогРабочейКопии);
	МаксимальнаяВерсияДляРазбора = ОпределитьМаксимальнуюВерсиюВХранилище(ТаблицаВерсий);

	Лог.Информация("Номер синхронизированной версии: " + ТекущаяВерсия);
	Лог.Информация("Номер последней версии в хранилище: " + МаксимальнаяВерсияДляРазбора);

	Возврат ТекущаяВерсия < МаксимальнаяВерсияДляРазбора;

КонецФункции

// Возвращает имя файла авторов
//
// Возвращаемое значение:
//   Строка - Имя файла авторов
//
Функция ИмяФайлаАвторов() Экспорт
	Возврат "AUTHORS";
КонецФункции

// Возвращачет имя файла версий
//
// Возвращаемое значение:
//   Строка - Имя файла версий
//
Функция ИмяФайлаВерсииХранилища() Экспорт
	Возврат "VERSION";
КонецФункции

// Производит запись файла версий
//
// Параметры:
//   КаталогФайлаВерсий - Строка - путь к каталогу для записи файла
//   Версия - Строка, Число - номер записываемой версии
//
Процедура ЗаписатьФайлВерсийГит(Знач КаталогФайлаВерсий, Знач Версия = "") Экспорт

	ПутьКФайлуВерсий = ОбъединитьПути(КаталогФайлаВерсий, ИмяФайлаВерсииХранилища());
	Лог.Отладка("ПутьКФайлуВерсий = <%1>", ПутьКФайлуВерсий);
	Попытка
		Запись = Новый ЗаписьТекста(ПутьКФайлуВерсий, "utf-8");
		Запись.ЗаписатьСтроку("<?xml version=""1.0"" encoding=""UTF-8""?>");
		Запись.ЗаписатьСтроку("<VERSION>" + Версия + "</VERSION>");
		Запись.Закрыть();
	Исключение
		Если Запись <> Неопределено Тогда
			ОсвободитьОбъект(Запись);
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;

КонецПроцедуры

#КонецОбласти

#Область Вспомогательные_процедуры_и_функции

Функция НоваяТаблицаИсторииВерсий()

	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("НомерВерсии");
	Таблица.Колонки.Добавить("ГУИД_Автора");
	Таблица.Колонки.Добавить("Автор");
	Таблица.Колонки.Добавить("Тэг");
	Таблица.Колонки.Добавить("Дата");
	Таблица.Колонки.Добавить("Комментарий");
	Таблица.Колонки.Добавить("ПредставлениеАвтора");

	Возврат Таблица;

КонецФункции

Процедура ПроверитьПараметрыДоступаКХранилищу()

	Если АвторизацияВХранилище.ПользовательХранилища = Неопределено
		ИЛИ ПустаяСтрока(АвторизацияВХранилище.ПользовательХранилища) Тогда

		ВызватьИсключение "Не задан пользователь хранилища конфигурации.";

	КонецЕсли;

	Если АвторизацияВХранилище.ПарольХранилища = Неопределено Тогда

		АвторизацияВХранилище.ПарольХранилища = "";

	КонецЕсли;

КонецПроцедуры

Процедура НастроитьХранилищеКонфигурации(Знач ПутьКХранилищу, Знач ПараметрыАвторизацииВХранилище)

	Если ХранилищеКонфигурации = Неопределено Тогда
		ХранилищеКонфигурации = Новый МенеджерХранилищаКонфигурации;
		Конфигуратор = ХранилищеКонфигурации.ПолучитьУправлениеКонфигуратором();
		Конфигуратор.ИспользоватьВерсиюПлатформы("8.3");
	КонецЕсли;

	Логирование.ПолучитьЛог("oscript.lib.v8storage").УстановитьУровень(Лог.Уровень());
	ПроверитьПараметрыДоступаКХранилищу();
	ХранилищеКонфигурации.УстановитьПараметрыАвторизации(ПараметрыАвторизацииВХранилище.ПользовательХранилища,
														ПараметрыАвторизацииВХранилище.ПарольХранилища);
	ХранилищеКонфигурации.УстановитьПутьКХранилищу(ПутьКХранилищу);

КонецПроцедуры

Функция НоваяТаблицаПользователейХранилища()

	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Автор");
	Таблица.Колонки.Добавить("ГУИД_Автора");
	Таблица.Колонки.Добавить("ПредставлениеАвтора");

	Возврат Таблица;

КонецФункции

Функция ПодготовитьФайлКоммита(Знач Комментарий)

	ИмяФайлаКомментария = ВременныеФайлы.СоздатьФайл("txt");
	ФайлКомментария = Новый ЗаписьТекста(ИмяФайлаКомментария, КодировкаТекста.UTF8NoBOM);
	ФайлКомментария.Записать(?(ПустаяСтрока(Комментарий), ".", Комментарий));
	ФайлКомментария.Закрыть();
	Лог.Отладка(СтрШаблон("Текст коммита: %1", Комментарий));

	Возврат ИмяФайлаКомментария;

КонецФункции

Процедура ДополнитьТаблицуВерсийИменамиАвторов(Знач ТаблицаВерсий, Знач ТаблицаПользователей)

	Для Каждого Строка Из ТаблицаВерсий Цикл
		СтрокаПользователя = ТаблицаПользователей.Найти(Строка.ГУИД_Автора, "ГУИД_Автора");
		Если СтрокаПользователя = Неопределено Тогда
			Сообщение = "Не удалось найти автора коммита из хранилища 1С по номеру версии <%1>,
			| комментарий <%2>, ГУИД-у <%3> - ПолучитьТаблицуВерсийИзФайлаХранилища1С";
			Лог.Ошибка(СтрШаблон(Сообщение, Строка.НомерВерсии, Строка.Комментарий, Строка.ГУИД_Автора));
		Иначе
			Строка.Автор = СтрокаПользователя.Автор;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

Процедура ЗаписатьТаблицуПользователейВФайлАвторовGit(Знач ТаблицаПользователейХранилища,
													Знач ВыходнойФайл,
													Знач ДоменПочтыДляGit)

	ЗаписьФайла = Новый ЗаписьТекста(ВыходнойФайл, "utf-8");
	Попытка
		ШаблонЗаписи = "%1=%1 <%1@%2>";
		Для Каждого Запись Из ТаблицаПользователейХранилища Цикл
			СтрокаДляЗаписи = СтрШаблон(ШаблонЗаписи, Запись.Автор, ДоменПочтыДляGit);
			ЗаписьФайла.ЗаписатьСтроку(СтрокаДляЗаписи);
		КонецЦикла;

		ЗаписьФайла.Закрыть();
	Исключение
		ОсвободитьОбъект(ЗаписьФайла);
		ВызватьИсключение;
	КонецПопытки;

КонецПроцедуры

Функция НомерСинхронизированнойВерсии(Знач КаталогВыгрузки)

	ПутьФайлаВерсий = ОбъединитьПути(КаталогВыгрузки, ИмяФайлаВерсииХранилища());

	ТекущаяВерсия = ПрочитатьФайлВерсийГит(ПутьФайлаВерсий);
	Если ТекущаяВерсия <> Неопределено Тогда
		Попытка
			ТекущаяВерсия = Число(ТекущаяВерсия);
		Исключение
			ТекущаяВерсия = 0;
		КонецПопытки;
	Иначе
		ТекущаяВерсия = 0;
	КонецЕсли;

	Возврат ТекущаяВерсия;

КонецФункции

Функция ОпределитьМаксимальнуюВерсиюВХранилище(Знач ТаблицаИсторииХранилища)

	Если ТаблицаИсторииХранилища.Количество() = 0 Тогда
		Возврат 0;
	КонецЕсли;

	МаксимальнаяВерсия = Число(ТаблицаИсторииХранилища[0].НомерВерсии);
	Для Сч = 1 По ТаблицаИсторииХранилища.Количество() - 1 Цикл
		ЧислоВерсии = Число(ТаблицаИсторииХранилища[Сч].НомерВерсии);
		Если ЧислоВерсии > МаксимальнаяВерсия Тогда
			МаксимальнаяВерсия = ЧислоВерсии;
		КонецЕсли;
	КонецЦикла;

	Возврат МаксимальнаяВерсия;

КонецФункции

Функция ПрочитатьФайлВерсийГит(Знач ПутьКФайлуВерсий)

	Перем Версия;

	Если Не Новый Файл(ПутьКФайлуВерсий).Существует() Тогда
		ВызватьИсключение СтрШаблон("Файл с версией ГИТ <%1> не существует", ПутьКФайлуВерсий);
	КонецЕсли;

	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьФайл(ПутьКФайлуВерсий);

	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента И ЧтениеXML.Имя = "VERSION" Тогда

			Если Не ЧтениеXML.Прочитать() Тогда
				ВызватьИсключение "Чтение файла версий, у элемента Version нет текста";
			КонецЕсли;

			Если Не ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
				ВызватьИсключение "Чтение файла версий, у элемента Version нет текста";
			КонецЕсли;

			Версия = ЧтениеXML.Значение;
			Лог.Отладка("Предыдущая версия из хранилища 1С: <%1>", Версия);

			Прервать;
		КонецЕсли;

	КонецЦикла;

	ЧтениеXML.Закрыть();

	Возврат Версия;

КонецФункции

Процедура СгенерироватьФайлAUTHORS(Знач ПутьХранилища, Знач КаталогИсходников)

	ФайлАвторов = Новый Файл(ОбъединитьПути(КаталогИсходников, "AUTHORS"));
	Если ФайлАвторов.Существует() Тогда

		Лог.Информация("Файл <%1> уже существует. Пропускаем генерацию файла AUTHORS", ФайлАвторов.ПолноеИмя);
		Возврат;

	КонецЕсли;

	Попытка

		Лог.Отладка("Формирую файл AUTHORS в каталоге <%1>", КаталогИсходников);
		СформироватьПервичныйФайлПользователейДляGit(ПутьХранилища, ФайлАвторов.ПолноеИмя);
		Лог.Отладка("Файл сгенерирован");

	Исключение

		Лог.Ошибка("Не удалось сформировать файл авторов");
		ВызватьИсключение;

	КонецПопытки;

КонецПроцедуры

Процедура СгенерироватьФайлVERSION(Знач КаталогИсходников)

	ФайлВерсий = Новый Файл(ОбъединитьПути(КаталогИсходников, "VERSION"));
	Если ФайлВерсий.Существует() Тогда

		Лог.Информация("Файл <%1> уже существует. Пропускаем генерацию файла VERSION", ФайлВерсий.ПолноеИмя);
		Возврат;

	КонецЕсли;

	ЗаписатьФайлВерсийГит(ФайлВерсий.Путь);

КонецПроцедуры

// Удаляет временные файлы при необходимости
// Если передана пустая строка, то удаляются все зарегистрированные временные файлы
//
// Параметры:
//   ПутьКФайлу - Строка - полный путь файла или пустая строка
//
Процедура УдалитьВременныеФайлыПриНеобходимости(Знач ПутьКФайлу = "")

	Если УдалятьВременныеФайлы Тогда
		Возврат;
	КонецЕсли;

	Если ПутьКФайлу = "" Тогда
		ВременныеФайлы.Удалить();
	Иначе
		ВременныеФайлы.УдалитьФайл(ПутьКФайлу);
	КонецЕсли;

КонецПроцедуры

Процедура УстановитьОбработчикПодписок(НовыйИндексПодписчиков)

	ОбработчикПодписок.УстановитьПодписчиков(НовыйИндексПодписчиков);

	ОбработчикПодписок.ПриАктивизации(ЭтотОбъект);

КонецПроцедуры

Функция ИмяЛога()

	Возврат "oscript.lib.gitsync3";

КонецФункции

Функция ДатаPOSIX(Знач Дата)

	Возврат "" + Год(Дата) + "-" + ФорматДвузначноеЧисло(Месяц(Дата)) + "-" + ФорматДвузначноеЧисло(День(Дата)) + " "
			+ ФорматДвузначноеЧисло(Час(Дата)) + ":" + ФорматДвузначноеЧисло(Минута(Дата))
			+ ":" + ФорматДвузначноеЧисло(Секунда(Дата));

КонецФункции

Функция ЗапуститьПриложениеИДождатьсяЗавершения(Знач СтрокаЗапуска, Знач ТекущийКаталог = "\.")

	Результат = -1;
	Если НЕ ЭтоWindows И ТекущийКаталог = "\." Тогда
		ТекущийКаталог = "./";
	КонецЕсли;

	Попытка
		КодВозврата = "";
		ЗапуститьПриложение(СтрокаЗапуска, ТекущийКаталог, Истина, КодВозврата);
		Результат = КодВозврата;
	Исключение
		// Для x64 ОС
		Если ЭтоWindows Тогда
			СтрокаЗапуска = "%windir%\Sysnative\" + СтрокаЗапуска;
			КодВозврата = "";
			ЗапуститьПриложение(СтрокаЗапуска, ТекущийКаталог, Истина, КодВозврата);
			Результат = КодВозврата;
		КонецЕсли;
	КонецПопытки;

	Возврат Результат;

КонецФункции // ЗапуститьПриложениеИДождатьсяЗавершения()

Процедура ЗавершитьПроцесс_TGitCache_exe()
	Если ЭтоWindows Тогда
		СтрокаКоманды = "taskkill /im TGitCache.exe  /T /F";
		Лог.Отладка("ЗавершитьПроцесс_TGitCache_exe: команда "+ СтрокаКоманды);

		ЗапуститьПриложениеИДождатьсяЗавершения(СтрокаКоманды);
	КонецЕсли;
КонецПроцедуры

Функция ФорматДвузначноеЧисло(ЗначениеЧисло)
	ЧислоСтрокой = Строка(ЗначениеЧисло);
	Если СтрДлина(ЧислоСтрокой) < 2 Тогда
		ЧислоСтрокой = "0" + ЧислоСтрокой;
	КонецЕсли;

	Возврат ЧислоСтрокой;
КонецФункции

Функция ДоменПочтыДляGit()
	Возврат ?(ДоменПочтыДляGitПоУмолчанию = Неопределено, "localhost", ДоменПочтыДляGitПоУмолчанию);
КонецФункции

Процедура ПриСозданииОбъекта()

	ОбработчикПодписок = Новый МенеджерПодписок(Новый Соответствие);

	Лог = Логирование.ПолучитьЛог(ИмяЛога());

	УдалятьВременныеФайлы = Ложь;
	МинимальнаяРазницаМеждуКоммитамиНовогоХранилища = 10;
	АвторизацияВХранилище = Новый Структура("ПользовательХранилища, ПарольХранилища");

	КоличествоЦикловОжиданияЛицензииПоУмолчанию = 3;

	СистемнаяИнформация = Новый СистемнаяИнформация;
	ЭтоWindows = Найти(НРег(СистемнаяИнформация.ВерсияОС), "windows") > 0;

	ВерсияПлатформы = "8.3";

КонецПроцедуры

#КонецОбласти
